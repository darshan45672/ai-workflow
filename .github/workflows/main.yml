name: GitHub Native AI-Powered PR Selection

on:
  pull_request:
    types: [opened, synchronize, ready_for_review]
  schedule:
    - cron: '0 */2 * * *'
  workflow_dispatch:

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  detect-competing-prs:
    runs-on: ubuntu-latest
    outputs:
      competing-prs: ${{ steps.find-prs.outputs.competing-prs }}
      should-evaluate: ${{ steps.find-prs.outputs.should-evaluate }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Find competing PRs
        id: find-prs
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            
            const { data: prs } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 100
            });
            
            const featureGroups = {};
            
            for (const pr of prs) {
              const branchName = pr.head.ref;
              const titleLower = pr.title.toLowerCase();
              
              console.log(`ğŸ” Processing PR #${pr.number}: "${pr.title}" from branch "${branchName}"`);
              
              let featureKey = null;
              
              // Enhanced feature detection
              const branchMatch = branchName.match(/^(feature|bugfix|enhancement|fix|feat)([\/\-](.+)|[0-9]+)$/);
              if (branchMatch) {
                const prefix = branchMatch[1];
                const suffix = branchMatch[3] || branchMatch[2] || 'default';
                featureKey = `${prefix}-${suffix.split(/[\/\-]/)[0]}`;
              }
              
              // Label-based detection
              const featureLabels = pr.labels.filter(label => 
                label.name.startsWith('feature:') || 
                label.name.startsWith('area:') ||
                label.name.startsWith('type:')
              );
              if (featureLabels.length > 0) {
                featureKey = featureLabels[0].name;
              }
              
              // Keyword detection
              const keywords = [
                'auth', 'login', 'user', 'dashboard', 'api', 'database', 'ui', 'frontend', 'backend',
                'crud', 'rest', 'graphql', 'middleware', 'service', 'controller', 'model', 'view',
                'calculator', 'calc', 'math', 'compute', 'operation', 'function'
              ];
              
              for (const keyword of keywords) {
                if (titleLower.includes(keyword)) {
                  featureKey = featureKey || `keyword-${keyword}`;
                  console.log(`ğŸ“ Found keyword "${keyword}" in title, setting featureKey to: ${featureKey}`);
                  break;
                }
              }
              
              console.log(`ğŸ¯ Final featureKey for PR #${pr.number}: ${featureKey || 'none'}`);
              
              if (featureKey) {
                if (!featureGroups[featureKey]) {
                  featureGroups[featureKey] = [];
                }
                featureGroups[featureKey].push({
                  number: pr.number,
                  title: pr.title,
                  author: pr.user.login,
                  branch: pr.head.ref,
                  created_at: pr.created_at,
                  updated_at: pr.updated_at,
                  url: pr.html_url
                });
              }
            }
            
            const competingGroups = Object.entries(featureGroups)
              .filter(([key, prs]) => prs.length > 1)
              .reduce((acc, [key, prs]) => {
                acc[key] = prs;
                return acc;
              }, {});
            
            const shouldEvaluate = Object.keys(competingGroups).length > 0;
            
            console.log(`ğŸ“Š Found ${Object.keys(featureGroups).length} feature groups:`);
            console.log(JSON.stringify(featureGroups, null, 2));
            console.log(`ğŸ“Š Found ${Object.keys(competingGroups).length} competing groups:`);
            console.log(JSON.stringify(competingGroups, null, 2));
            console.log(`ğŸš€ Should evaluate: ${shouldEvaluate}`);
            
            core.setOutput('competing-prs', JSON.stringify(competingGroups));
            core.setOutput('should-evaluate', shouldEvaluate);

  github-native-evaluation:
    needs: detect-competing-prs
    if: needs.detect-competing-prs.outputs.should-evaluate == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        feature: ${{ fromJson(needs.detect-competing-prs.outputs.competing-prs) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: GitHub Native AI Evaluation
        id: evaluate
        env:
          COMPETING_PRS: ${{ toJson(matrix.feature) }}
        uses: actions/github-script@v7
        with:
          script: |
            const evaluations = [];
            const competingPRs = JSON.parse(process.env.COMPETING_PRS);
            
            for (const prData of competingPRs) {
              console.log(`ğŸ”„ Evaluating PR #${prData.number}: ${prData.title}`);
              
              // Get PR details using GitHub API
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prData.number
              });
              
              // Get PR files
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prData.number
              });
              
              // Get PR commits
              const { data: commits } = await github.rest.pulls.listCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prData.number
              });
              
              // Initialize evaluation scores
              let evaluation = {
                pr_number: prData.number,
                title: prData.title,
                author: prData.author,
                scores: {},
                total_score: 0,
                details: {}
              };
              
              // 1. Code Quality Score (based on GitHub's analysis)
              let codeQualityScore = 50; // Base score
              
              // Analyze file changes
              const totalAdditions = files.reduce((sum, file) => sum + file.additions, 0);
              const totalDeletions = files.reduce((sum, file) => sum + file.deletions, 0);
              const filesChanged = files.length;
              
              // Prefer smaller, focused changes
              if (filesChanged <= 5) codeQualityScore += 15;
              else if (filesChanged <= 10) codeQualityScore += 10;
              else if (filesChanged > 20) codeQualityScore -= 10;
              
              // Analyze addition to deletion ratio
              const changeRatio = totalDeletions > 0 ? totalAdditions / totalDeletions : totalAdditions;
              if (changeRatio < 3) codeQualityScore += 10; // Good refactoring
              if (changeRatio > 10) codeQualityScore -= 5; // Too many additions
              
              evaluation.scores.code_quality = Math.max(0, Math.min(100, codeQualityScore));
              evaluation.details.files_changed = filesChanged;
              evaluation.details.additions = totalAdditions;
              evaluation.details.deletions = totalDeletions;
              
              // 2. Git Quality Score (commit analysis)
              let gitQualityScore = 0;
              const conventionalCommitPattern = /^(feat|fix|docs|style|refactor|test|chore)(\(.+\))?: .{10,}/;
              
              let goodCommits = 0;
              for (const commit of commits) {
                if (conventionalCommitPattern.test(commit.commit.message)) {
                  goodCommits++;
                }
              }
              
              gitQualityScore = commits.length > 0 ? (goodCommits / commits.length) * 100 : 0;
              evaluation.scores.git_quality = gitQualityScore;
              evaluation.details.total_commits = commits.length;
              evaluation.details.good_commits = goodCommits;
              
              // 3. PR Description Quality
              let descriptionScore = 0;
              const description = pr.body || '';
              
              if (description.length > 50) descriptionScore += 30;
              if (description.includes('##') || description.includes('**')) descriptionScore += 20; // Has formatting
              if (description.includes('test') || description.includes('Test')) descriptionScore += 20;
              if (description.includes('fix') || description.includes('Fix')) descriptionScore += 15;
              if (description.length > 200) descriptionScore += 15;
              
              evaluation.scores.description_quality = Math.min(100, descriptionScore);
              evaluation.details.description_length = description.length;
              
              // 4. Timing Score (earlier PRs get slight advantage)
              const createdAt = new Date(prData.created_at);
              const now = new Date();
              const ageInHours = (now - createdAt) / (1000 * 60 * 60);
              
              let timingScore = 50;
              if (ageInHours > 168) timingScore += 20; // Week old PRs get bonus for stability
              else if (ageInHours > 24) timingScore += 10; // Day old PRs get small bonus
              
              evaluation.scores.timing = timingScore;
              evaluation.details.age_hours = Math.round(ageInHours);
              
              // 5. File Type Analysis
              let fileTypeScore = 50;
              const hasTests = files.some(file => 
                file.filename.includes('test') || 
                file.filename.includes('spec') ||
                file.filename.includes('__tests__')
              );
              const hasDocumentation = files.some(file => 
                file.filename.includes('README') || 
                file.filename.includes('doc') ||
                file.filename.includes('.md')
              );
              
              if (hasTests) fileTypeScore += 25;
              if (hasDocumentation) fileTypeScore += 15;
              
              // Check for config files (usually good)
              const hasConfig = files.some(file => 
                file.filename.includes('config') ||
                file.filename.includes('.json') ||
                file.filename.includes('.yml') ||
                file.filename.includes('.yaml')
              );
              if (hasConfig) fileTypeScore += 10;
              
              evaluation.scores.file_analysis = Math.min(100, fileTypeScore);
              evaluation.details.has_tests = hasTests;
              evaluation.details.has_documentation = hasDocumentation;
              evaluation.details.has_config = hasConfig;
              
              // Calculate total score with weights
              evaluation.total_score = 
                (evaluation.scores.code_quality * 0.30) +
                (evaluation.scores.git_quality * 0.25) +
                (evaluation.scores.description_quality * 0.20) +
                (evaluation.scores.file_analysis * 0.15) +
                (evaluation.scores.timing * 0.10);
              
              evaluations.push(evaluation);
              console.log(`âœ… PR #${prData.number} scored: ${evaluation.total_score.toFixed(2)}`);
            }
            
            // Find winner
            const winner = evaluations.reduce((prev, current) => 
              (prev.total_score > current.total_score) ? prev : current
            );
            
            // Save results
            const results = {
              feature_group: Object.keys(JSON.parse(process.env.COMPETING_PRS))[0],
              evaluations: evaluations,
              winner: winner,
              timestamp: new Date().toISOString()
            };
            
            const fs = require('fs');
            fs.writeFileSync('pr-evaluations.json', JSON.stringify(results, null, 2));
            
            core.setOutput('winner-pr', winner.pr_number);
            core.setOutput('evaluations', JSON.stringify(evaluations));

      - name: Upload evaluation results
        uses: actions/upload-artifact@v4
        with:
          name: pr-evaluations-${{ strategy.job-index }}
          path: pr-evaluations.json

  merge-winner:
    needs: [detect-competing-prs, github-native-evaluation]
    runs-on: ubuntu-latest
    if: needs.detect-competing-prs.outputs.should-evaluate == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download evaluation results
        uses: actions/download-artifact@v4
        with:
          pattern: pr-evaluations-*
          merge-multiple: true

      - name: Process results and merge winners
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const evaluationFiles = fs.readdirSync('.').filter(f => f.startsWith('pr-evaluations'));
            
            for (const file of evaluationFiles) {
              const evaluation = JSON.parse(fs.readFileSync(file, 'utf8'));
              const winner = evaluation.winner;
              const losers = evaluation.evaluations.filter(e => e.pr_number !== winner.pr_number);
              
              console.log(`ğŸ† Winner: PR #${winner.pr_number} with score ${winner.total_score.toFixed(2)}`);
              
              // Create detailed winner comment
              const winnerComment = `ğŸ† **GitHub Native AI Workflow Winner!**
              This PR has been selected as the best implementation with a score of **${winner.total_score.toFixed(2)}/100**.
              **ğŸ“Š Detailed Evaluation Breakdown:**
              - ğŸ” **Code Quality**: ${winner.scores.code_quality?.toFixed(1)}/100
              - Files changed: ${winner.details.files_changed}
              - Lines added: ${winner.details.additions}
              - Lines deleted: ${winner.details.deletions}
              
              - ğŸ“ **Git Quality**: ${winner.scores.git_quality?.toFixed(1)}/100
              - Total commits: ${winner.details.total_commits}
              - Conventional commits: ${winner.details.good_commits}
              - ğŸ“š **Description Quality**: ${winner.scores.description_quality?.toFixed(1)}/100
              - Description length: ${winner.details.description_length} characters
              - ğŸ“ **File Analysis**: ${winner.scores.file_analysis?.toFixed(1)}/100
              - Has tests: ${winner.details.has_tests ? 'âœ…' : 'âŒ'}
              - Has documentation: ${winner.details.has_documentation ? 'âœ…' : 'âŒ'}
              - Has config files: ${winner.details.has_config ? 'âœ…' : 'âŒ'}
              - â° **Timing**: ${winner.scores.timing?.toFixed(1)}/100
              - PR age: ${winner.details.age_hours} hours
              **ğŸƒâ€â™€ï¸ Competing PRs:**
              ${losers.map(pr => `- PR #${pr.pr_number} by @${pr.author}: ${pr.total_score.toFixed(2)}/100`).join('\n')}

              *Evaluated using GitHub's native analysis tools! ğŸš€*`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: winner.pr_number,
                body: winnerComment
              });

              // Comment on losing PRs
              for (const loser of losers) {
                const loserComment = `ğŸ¤– **GitHub Native AI Evaluation Results**

                Your PR was evaluated but not selected for automatic merge.

                **ğŸ“Š Your Score:** ${loser.total_score.toFixed(2)}/100
                **ğŸ† Winner:** PR #${winner.pr_number} with ${winner.total_score.toFixed(2)}/100


                **Your Detailed Breakdown:**

                - ğŸ” Code Quality: ${loser.scores.code_quality?.toFixed(1)}/100 (${loser.details.files_changed} files, +${loser.details.additions}/-${loser.details.deletions} lines)

                - ğŸ“ Git Quality: ${loser.scores.git_quality?.toFixed(1)}/100 (${loser.details.good_commits}/${loser.details.total_commits} conventional commits)

                - ğŸ“š Description: ${loser.scores.description_quality?.toFixed(1)}/100 (${loser.details.description_length} chars)

                - ğŸ“ File Analysis: ${loser.scores.file_analysis?.toFixed(1)}/100

                - â° Timing: ${loser.scores.timing?.toFixed(1)}/100


                **ğŸ’¡ Improvement Suggestions:**

                ${loser.scores.git_quality < 50 ? '- Use conventional commit messages (feat:, fix:, docs:, etc.)\n' : ''}${loser.scores.description_quality < 50 ? '- Add a more detailed PR description\n' : ''}${!loser.details.has_tests ? '- Add tests for your changes\n' : ''}${!loser.details.has_documentation ? '- Update documentation\n' : ''}

                Consider the winning implementation's strengths for future contributions! ğŸš€`;

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: loser.pr_number,
                  body: loserComment
                });
              }
              
              // Approve and merge winner
              try {
                // First, check if we can merge (all checks passed, etc.)
                const { data: prDetails } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: winner.pr_number
                });
                
                if (prDetails.mergeable && !prDetails.draft) {
                  await github.rest.pulls.createReview({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: winner.pr_number,
                    event: 'APPROVE',
                    body: 'ğŸ¤– Automatically approved by GitHub Native AI Workflow'
                  });
                  
                  await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: winner.pr_number,
                    commit_title: `ğŸ¤– Auto-merge: ${winner.title}`,
                    commit_message: `Automatically merged by GitHub Native AI Workflow\n\nScore: ${winner.total_score.toFixed(2)}/100\nEvaluation: GitHub native analysis`,
                    merge_method: 'squash'
                  });
                  
                  console.log(`âœ… Successfully merged PR #${winner.pr_number}`);
                } else {
                  throw new Error('PR not mergeable or is draft');
                }
                
              } catch (error) {
                console.log(`âŒ Failed to merge PR #${winner.pr_number}:`, error.message);
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: winner.pr_number,
                  body: `âš ï¸ **Auto-merge failed**: ${error.message}\n\nThis PR won the evaluation but couldn't be merged automatically. Please merge manually after reviewing the results.`
                });
              }
            }
                });
              }
            }