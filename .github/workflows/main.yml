name: GitHub Native AI-Powered PR Selection

# Trigger test: Fixed syntax errors and matrix strategy issues
on:
  pull_request:
    types: [opened, synchronize, ready_for_review]
  schedule:
    - cron: '0 */2 * * *'
  workflow_dispatch:

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  detect-competing-prs:
    runs-on: ubuntu-latest
    outputs:
      competing-prs: ${{ steps.find-prs.outputs.competing-prs }}
      should-evaluate: ${{ steps.find-prs.outputs.should-evaluate }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Find competing PRs
        id: find-prs
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            
            const { data: prs } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 100
            });
            
            const featureGroups = {};
            
            for (const pr of prs) {
              const branchName = pr.head.ref;
              const titleLower = pr.title.toLowerCase();
              
              console.log(`üîç Processing PR #${pr.number}: "${pr.title}" from branch "${branchName}"`);
              
              let featureKey = null;
              
              // Enhanced feature detection
              const branchMatch = branchName.match(/^(feature|bugfix|enhancement|fix|feat)([\/\-](.+)|[0-9]+)$/);
              if (branchMatch) {
                const prefix = branchMatch[1];
                // Group all feature branches together, regardless of suffix
                featureKey = `${prefix}-branch`;
                console.log(`üîç Branch match found: ${branchName} -> ${featureKey}`);
              }
              
              // Label-based detection
              const featureLabels = pr.labels.filter(label => 
                label.name.startsWith('feature:') || 
                label.name.startsWith('area:') ||
                label.name.startsWith('type:')
              );
              if (featureLabels.length > 0) {
                featureKey = featureLabels[0].name;
              }
              
              // Keyword detection
              const keywords = [
                'auth', 'login', 'user', 'dashboard', 'api', 'database', 'ui', 'frontend', 'backend',
                'crud', 'rest', 'graphql', 'middleware', 'service', 'controller', 'model', 'view',
                'calculator', 'calc', 'math', 'compute', 'operation', 'function'
              ];
              
              for (const keyword of keywords) {
                if (titleLower.includes(keyword)) {
                  featureKey = `keyword-${keyword}`;  // Override branch-based grouping
                  console.log(`üìç Found keyword "${keyword}" in title, setting featureKey to: ${featureKey}`);
                  break;
                }
              }
              
              console.log(`üéØ Final featureKey for PR #${pr.number}: ${featureKey || 'none'}`);
              
              if (featureKey) {
                if (!featureGroups[featureKey]) {
                  featureGroups[featureKey] = [];
                }
                featureGroups[featureKey].push({
                  number: pr.number,
                  title: pr.title,
                  author: pr.user.login,
                  branch: pr.head.ref,
                  created_at: pr.created_at,
                  updated_at: pr.updated_at,
                  url: pr.html_url
                });
              }
            }
            
            const competingGroups = Object.entries(featureGroups)
              .filter(([key, prs]) => prs.length > 1)
              .reduce((acc, [key, prs]) => {
                acc[key] = prs;
                return acc;
              }, {});
            
            const shouldEvaluate = Object.keys(competingGroups).length > 0;
            
            console.log(`üìä Found ${Object.keys(featureGroups).length} feature groups:`);
            console.log(JSON.stringify(featureGroups, null, 2));
            console.log(`üìä Found ${Object.keys(competingGroups).length} competing groups:`);
            console.log(JSON.stringify(competingGroups, null, 2));
            console.log(`üöÄ Should evaluate: ${shouldEvaluate}`);
            
            core.setOutput('competing-prs', JSON.stringify(competingGroups));
            core.setOutput('should-evaluate', shouldEvaluate);

  github-native-evaluation:
    needs: detect-competing-prs
    if: needs.detect-competing-prs.outputs.should-evaluate == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: GitHub Native AI Evaluation
        id: evaluate
        env:
          COMPETING_GROUPS: ${{ needs.detect-competing-prs.outputs.competing-prs }}
        uses: actions/github-script@v7
        with:
          script: |
            const competingGroups = JSON.parse(process.env.COMPETING_GROUPS);
            const allEvaluations = [];
            
            // Process each competing group
            for (const [groupName, competingPRs] of Object.entries(competingGroups)) {
              console.log(`üìä Evaluating group: ${groupName} with ${competingPRs.length} PRs`);
              
              const evaluations = [];
              
              for (const prData of competingPRs) {
                console.log(`üîÑ Evaluating PR #${prData.number}: ${prData.title}`);
                
                // Get PR details using GitHub API
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prData.number
                });
                
                // Get PR files
                const { data: files } = await github.rest.pulls.listFiles({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prData.number
                });
                
                // Get PR commits
                const { data: commits } = await github.rest.pulls.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prData.number
                });
                
                // Initialize evaluation scores
                let evaluation = {
                  pr_number: prData.number,
                  title: prData.title,
                  author: prData.author,
                  scores: {},
                  total_score: 0,
                  details: {},
                  group: groupName
                };
                
                // 1. Code Quality Score (based on GitHub's analysis)
                let codeQualityScore = 50; // Base score
                
                // Analyze file changes
                const totalAdditions = files.reduce((sum, file) => sum + file.additions, 0);
                const totalDeletions = files.reduce((sum, file) => sum + file.deletions, 0);
                const filesChanged = files.length;
                
                // Prefer smaller, focused changes
                if (filesChanged <= 5) codeQualityScore += 15;
                else if (filesChanged <= 10) codeQualityScore += 10;
                else if (filesChanged > 20) codeQualityScore -= 10;
                
                // Analyze addition to deletion ratio
                const changeRatio = totalDeletions > 0 ? totalAdditions / totalDeletions : totalAdditions;
                if (changeRatio < 3) codeQualityScore += 10; // Good refactoring
                if (changeRatio > 10) codeQualityScore -= 5; // Too many additions
                
                evaluation.scores.code_quality = Math.max(0, Math.min(100, codeQualityScore));
                evaluation.details.files_changed = filesChanged;
                evaluation.details.additions = totalAdditions;
                evaluation.details.deletions = totalDeletions;
                
                // 2. Git Quality Score (commit analysis)
                let gitQualityScore = 0;
                const conventionalCommitPattern = /^(feat|fix|docs|style|refactor|test|chore)(\(.+\))?: .{10,}/;
                
                let goodCommits = 0;
                for (const commit of commits) {
                  if (conventionalCommitPattern.test(commit.commit.message)) {
                    goodCommits++;
                  }
                }
                
                gitQualityScore = commits.length > 0 ? (goodCommits / commits.length) * 100 : 0;
                evaluation.scores.git_quality = gitQualityScore;
                evaluation.details.total_commits = commits.length;
                evaluation.details.good_commits = goodCommits;
                
                // 3. PR Description Quality
                let descriptionScore = 0;
                const description = pr.body || '';
                
                if (description.length > 50) descriptionScore += 30;
                if (description.includes('##') || description.includes('**')) descriptionScore += 20; // Has formatting
                if (description.includes('test') || description.includes('Test')) descriptionScore += 20;
                if (description.includes('fix') || description.includes('Fix')) descriptionScore += 15;
                if (description.length > 200) descriptionScore += 15;
                
                evaluation.scores.description_quality = Math.min(100, descriptionScore);
                evaluation.details.description_length = description.length;
                
                // 4. Timing Score (earlier PRs get slight advantage)
                const createdAt = new Date(prData.created_at);
                const now = new Date();
                const ageInHours = (now - createdAt) / (1000 * 60 * 60);
                
                let timingScore = 50;
                if (ageInHours > 168) timingScore += 20; // Week old PRs get bonus for stability
                else if (ageInHours > 24) timingScore += 10; // Day old PRs get small bonus
                
                evaluation.scores.timing = timingScore;
                evaluation.details.age_hours = Math.round(ageInHours);
                
                // 5. File Type Analysis
                let fileTypeScore = 50;
                const hasTests = files.some(file => 
                  file.filename.includes('test') || 
                  file.filename.includes('spec') ||
                  file.filename.includes('__tests__')
                );
                const hasDocumentation = files.some(file => 
                  file.filename.includes('README') || 
                  file.filename.includes('doc') ||
                  file.filename.includes('.md')
                );
                
                if (hasTests) fileTypeScore += 25;
                if (hasDocumentation) fileTypeScore += 15;
                
                // Check for config files (usually good)
                const hasConfig = files.some(file => 
                  file.filename.includes('config') ||
                  file.filename.includes('.json') ||
                  file.filename.includes('.yml') ||
                  file.filename.includes('.yaml')
                );
                if (hasConfig) fileTypeScore += 10;
                
                evaluation.scores.file_analysis = Math.min(100, fileTypeScore);
                evaluation.details.has_tests = hasTests;
                evaluation.details.has_documentation = hasDocumentation;
                evaluation.details.has_config = hasConfig;
                
                // Calculate total score with weights
                evaluation.total_score = 
                  (evaluation.scores.code_quality * 0.30) +
                  (evaluation.scores.git_quality * 0.25) +
                  (evaluation.scores.description_quality * 0.20) +
                  (evaluation.scores.file_analysis * 0.15) +
                  (evaluation.scores.timing * 0.10);
                
                evaluations.push(evaluation);
                console.log(`‚úÖ PR #${prData.number} scored: ${evaluation.total_score.toFixed(2)}`);
              }
              
              // Find winner for this group
              const winner = evaluations.reduce((prev, current) => 
                (prev.total_score > current.total_score) ? prev : current
              );
              
              // Save results for this group
              const results = {
                feature_group: groupName,
                evaluations: evaluations,
                winner: winner,
                timestamp: new Date().toISOString()
              };
              
              allEvaluations.push(results);
            }
            
            // Save all results
            const fs = require('fs');
            fs.writeFileSync('pr-evaluations.json', JSON.stringify(allEvaluations, null, 2));
            
            core.setOutput('all-evaluations', JSON.stringify(allEvaluations));

  merge-winner:
    needs: [detect-competing-prs, github-native-evaluation]
    if: needs.detect-competing-prs.outputs.should-evaluate == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Merge Winner PR
        uses: actions/github-script@v7
        with:
          script: |
            const evaluationsJson = '${{ needs.github-native-evaluation.outputs.all-evaluations }}';
            
            if (!evaluationsJson || evaluationsJson === '') {
              console.log('‚ùå No evaluations found - this should not happen if workflow conditions are correct');
              return;
            }
            
            const allEvaluations = JSON.parse(evaluationsJson);
            
            for (const groupResults of allEvaluations) {
              const winner = groupResults.winner;
              
              console.log(`üèÜ Winner for group ${groupResults.feature_group}: PR #${winner.pr_number} with score ${winner.total_score.toFixed(2)}`);
              
              // Get the winning PR details
              const { data: winnerPR } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: winner.pr_number
              });
              
              console.log(`üìã Winner PR details:`);
              console.log(`   Title: ${winnerPR.title}`);
              console.log(`   Author: ${winnerPR.user.login}`);
              console.log(`   Branch: ${winnerPR.head.ref}`);
              console.log(`   Target: ${winnerPR.base.ref}`);
              
              // Check if PR can be merged
              if (winnerPR.state === 'open' && winnerPR.mergeable) {
                try {
                  // Add evaluation results as a comment before merging
                  const evaluationComment = '## ü§ñ AI-Powered PR Selection Results\\n\\n' +
                    '**üèÜ This PR has been selected as the winner!**\\n\\n' +
                    '### Evaluation Scores:\\n' +
                    '- **Code Quality**: ' + winner.scores.code_quality.toFixed(1) + '/100 (30% weight)\\n' +
                    '- **Git Quality**: ' + winner.scores.git_quality.toFixed(1) + '/100 (25% weight)\\n' +
                    '- **Description Quality**: ' + winner.scores.description_quality.toFixed(1) + '/100 (20% weight)\\n' +
                    '- **File Analysis**: ' + winner.scores.file_analysis.toFixed(1) + '/100 (15% weight)\\n' +
                    '- **Timing**: ' + winner.scores.timing.toFixed(1) + '/100 (10% weight)\\n\\n' +
                    '**Total Score: ' + winner.total_score.toFixed(2) + '/100**\\n\\n' +
                    '### Analysis Details:\\n' +
                    '- Files Changed: ' + winner.details.files_changed + '\\n' +
                    '- Lines Added: ' + winner.details.additions + '\\n' +
                    '- Lines Deleted: ' + winner.details.deletions + '\\n' +
                    '- Commits: ' + winner.details.total_commits + ' (' + winner.details.good_commits + ' well-formatted)\\n' +
                    '- Has Tests: ' + (winner.details.has_tests ? '‚úÖ' : '‚ùå') + '\\n' +
                    '- Has Documentation: ' + (winner.details.has_documentation ? '‚úÖ' : '‚ùå') + '\\n' +
                    '- Age: ' + winner.details.age_hours + ' hours\\n\\n' +
                    '### Competing PRs:\\n' +
                    groupResults.evaluations.map(eval => '- PR #' + eval.pr_number + ': ' + eval.title + ' - Score: ' + eval.total_score.toFixed(2)).join('\\n') + '\\n\\n' +
                    '*Automatically merged by GitHub Native AI-Powered PR Selection*';
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: winner.pr_number,
                    body: evaluationComment
                  });
                  
                  // Merge the winning PR
                  const mergeResult = await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: winner.pr_number,
                    commit_title: 'ü§ñ Auto-merge: ' + winnerPR.title,
                    commit_message: 'Automatically merged by AI-Powered PR Selection\\n\\nScore: ' + winner.total_score.toFixed(2) + '/100\\nGroup: ' + groupResults.feature_group + '\\nTimestamp: ' + groupResults.timestamp,
                    merge_method: 'squash'
                  });
                  
                  console.log(`‚úÖ Successfully merged PR #${winner.pr_number}`);
                  console.log(`   Merge SHA: ${mergeResult.data.sha}`);
                  
                  // Close competing PRs with explanation
                  for (const evaluation of groupResults.evaluations) {
                    if (evaluation.pr_number !== winner.pr_number) {
                      console.log(`‚ùå Closing competing PR #${evaluation.pr_number}`);
                      
                      const closeComment = '## ü§ñ AI-Powered PR Selection Results\\n\\n' +
                        '**This PR was not selected for automatic merging.**\\n\\n' +
                        'A competing PR (#' + winner.pr_number + ') was chosen based on evaluation scores:\\n\\n' +
                        '### Your PR\\'s Scores:\\n' +
                        '- **Code Quality**: ' + evaluation.scores.code_quality.toFixed(1) + '/100\\n' +
                        '- **Git Quality**: ' + evaluation.scores.git_quality.toFixed(1) + '/100\\n' +
                        '- **Description Quality**: ' + evaluation.scores.description_quality.toFixed(1) + '/100\\n' +
                        '- **File Analysis**: ' + evaluation.scores.file_analysis.toFixed(1) + '/100\\n' +
                        '- **Timing**: ' + evaluation.scores.timing.toFixed(1) + '/100\\n\\n' +
                        '**Your Total Score: ' + evaluation.total_score.toFixed(2) + '/100**\\n' +
                        '**Winning Score: ' + winner.total_score.toFixed(2) + '/100**\\n\\n' +
                        'Thank you for your contribution! Please consider the feedback for future PRs.\\n\\n' +
                        '*Automatically closed by GitHub Native AI-Powered PR Selection*';
                      
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: evaluation.pr_number,
                        body: closeComment
                      });
                      
                      await github.rest.pulls.update({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        pull_number: evaluation.pr_number,
                        state: 'closed'
                      });
                    }
                  }
                  
                } catch (error) {
                  console.error(`‚ùå Failed to merge PR #${winner.pr_number}:`, error);
                  
                  // Add comment about merge failure
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: winner.pr_number,
                    body: '## ‚ö†Ô∏è Auto-merge Failed\\n\\nThis PR was selected as the winner (score: ' + winner.total_score.toFixed(2) + ') but could not be automatically merged.\\n\\nError: ' + error.message + '\\n\\nPlease review and merge manually.'
                  });
                }
              } else {
                console.log(`‚ö†Ô∏è Cannot merge PR #${winner.pr_number}: state=${winnerPR.state}, mergeable=${winnerPR.mergeable}`);
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: winner.pr_number,
                  body: '## üèÜ AI Selection Winner!\\n\\nThis PR scored ' + winner.total_score.toFixed(2) + '/100 and was selected as the winner, but cannot be automatically merged.\\n\\nReason: PR state is \\'' + winnerPR.state + '\\' and mergeable status is \\'' + winnerPR.mergeable + '\\'\\n\\nPlease review and merge manually.'
                });
              }
            }